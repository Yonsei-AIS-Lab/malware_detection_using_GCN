import torch
import torch.nn.functional as F
from torch.nn import Linear
from torch_geometric.nn import GCNConv, global_add_pool
from torch_geometric.datasets import MalNetTiny
from torch_geometric.transforms import LocalDegreeProfile

import numpy as np

global subbed_edges
subbed_edges = []

class GCN(torch.nn.Module):
    def __init__(self, num_layers, hidden_dim, dropout):
        super(GCN, self).__init__()
        self.args = {"num_layers":num_layers,
                    "hidden_dim":hidden_dim,
                    "dropout":dropout}
        
        self.layers = torch.nn.ModuleList([])
        for i in range(self.args["num_layers"]):
            if i == 0:
                self.layers.append(GCNConv(5, self.args["hidden_dim"]))
            else:
                self.layers.append(GCNConv(self.args["hidden_dim"], self.args["hidden_dim"]))
        
        self.fc1 = Linear(self.args["hidden_dim"], self.args["hidden_dim"])
        self.fc2 = Linear(self.args["hidden_dim"], 5)
        
    def forward(self, x, edge_index, batch):
        for i, layer in enumerate(self.layers):
            x = layer(x, edge_index)
            x = F.relu(x)
        x = global_add_pool(x, batch)
        
        x = F.relu(self.fc1(x))
        if self.args["dropout"] > 0:
            x = F.dropout(x, p=self.args["dropout"], training=self.training)
        x = self.fc2(x)
        return F.log_softmax(x, dim=1)


def get_confidence_and_label(pred):
    confidence = torch.max(pred)
    label = torch.argmax(pred)
    
    confidence = torch.exp(confidence)
    return confidence, label


def sub_random_edge(data):
    global subbed_edges
    
    if data.x is None or len(data.x) == 0:
        raise ValueError("data.x is empty or not defined.")
    
    edge_index = data.edge_index.cpu().numpy()
    edge_list = edge_index.T.tolist()
    
    # 이미 제거된 엣지를 edge_list에서 제거
    for edge in subbed_edges:
        if edge in edge_list:
            edge_list.remove(edge)
        if edge[::-1] in edge_list:
            edge_list.remove(edge[::-1])
    
    if len(edge_list) == 0:
        return data, None
    
    # 랜덤 엣지 선택
    edge = edge_list[np.random.choice(len(edge_list))]
    subbed_edges.append(edge)
    
    # 엣지 제거
    edge_tensor = torch.tensor(edge, dtype=torch.long).view(2, 1)
    mask = (data.edge_index != edge_tensor).all(0)
    new_edge_index = data.edge_index[:, mask]
    
    # LocalDegreeProfile 적용 (기존의 node feature 제거)
    transformed_data = transform_data(data.__class__().from_dict({
        'edge_index': new_edge_index
    }))
    
    return transformed_data, edge

def restore_edge(data, edge_info):
    # edge_info를 2차원 텐서로 변환하고 transpose
    edge_info_tensor = torch.tensor([edge_info], dtype=torch.long).t()
    
    # add edge
    restored_edge_index = torch.cat([data.edge_index, edge_info_tensor], dim=1)
    
    # LocalDegreeProfile 적용 (기존의 node feature 제거)
    restored_data = transform_data(data.__class__().from_dict({
        'edge_index': restored_edge_index
    }))
    
    return restored_data


def attack_model(idx):
    global subbed_edges
    data = dataset[idx]
    print(data.x.shape)
    initial_pred = model(data.x, data.edge_index, data.batch)
    initial_confidence, initial_label = get_confidence_and_label(initial_pred)
    initial_pred = initial_pred.detach().numpy()

    iter_max = 100
    prev_confidence = initial_confidence
    confidences = []
    cnt = 0
    after_pred = None
    subbed_edges = []
    
    for i in range(iter_max):
        data, edge_info = sub_random_edge(data)
        if edge_info is None:
            return -1, confidences, initial_pred, after_pred
        
        pred = model(data.x, data.edge_index, data.batch)
        confidence, label = get_confidence_and_label(pred)
        confidences.append(confidence)
        
        if label != initial_label:
            after_pred = pred.detach().numpy()
            return cnt, confidences, initial_pred, after_pred
        elif confidence < prev_confidence:
            prev_confidence = confidence
            cnt += 1
        else:
            data = restore_edge(data, edge_info)
    return -1, confidences, initial_pred, after_pred


model = GCN(6, 128, 0.0)
model.load_state_dict(torch.load('./edge_subtraction/saves/GCN_932_6_128_0_0.001_200.pt', map_location=torch.device('cpu')))
model.eval()

transform_data = LocalDegreeProfile()

torch.manual_seed(42)
dataset = MalNetTiny(root='./data', transform=transform_data)
n = len(dataset)

info_dict = {}
success = []
fail = []
for idx in range(n):
    cnt, confidences, initial_pred, after_pred = attack_model(idx)
    info_dict[idx] = [cnt, confidences, initial_pred, after_pred]
    if cnt == -1:
        fail.append(idx)
        print(f"{idx+1} / {n}번째 데이터 : 공격 실패")
    else:
        success.append(cnt)
        print(f"{idx+1} / {n}번째 데이터 : {cnt}번째 iteration에서 공격 성공")

print("공격 성공률 :", len(success) / n * 100, "%")
print("평균 추가 엣지 수 :", np.mean(success))