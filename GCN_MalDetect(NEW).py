from utils import *

import torch.nn as nn
from torch_geometric.nn import GCNConv
from torch_geometric.data import DataLoader
import torch.nn.functional as F
class GCN(torch.nn.Module):
    def __init__(self, nb_features, nb_classes):
        super().__init__()
        self.conv1 = GCNConv(nb_features, 64)
        self.conv2 = GCNConv(64, nb_classes)

    def forward(self, data):
        x, edge_index = data.x, data.edge_index

        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = F.dropout(x, training=self.training)
        x = self.conv2(x, edge_index)

        return F.log_softmax(x, dim=1)
    
def train(model, dataset):
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    model = model.to(device)

    optimizer = torch.optim.Adam(model.parameters(), lr=0.001, weight_decay=5e-4)

    for epoch in range(100):
        model.train()
        optimizer.zero_grad()
        
        cnt = 0
        total_loss = 0
        total_acc = 0
        for data in dataset:
            data = data.to(device)
            target = data.y.to(device)

            output = model(data)

            pred = torch.argmax(output, dim=1)
            correct = torch.eq(pred, target).sum().item()
            acc = correct / len(target)

            loss = F.nll_loss(output, target)
            loss.backward()
            optimizer.step()

            total_loss += loss
            total_acc += acc
            cnt += 1

        print(f'{epoch:>3} Epochs: {total_loss/cnt:.2f} / {total_acc/cnt*100:.2f}%')
    
if __name__ == '__main__':
    file_name = './datasets/security_train.csv'
    data = pd.read_csv(file_name)

    nb_files, nb_data, nb_labels, nb_apis = get_data_info(data)
    processed_data = preprocessing_graph_data(data, nb_files)

    data_loader = DataLoader(processed_data, batch_size=16, shuffle=True)

    model = GCN(5, nb_labels)

    train(model, data_loader)